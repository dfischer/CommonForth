// Graphics Tools From GRX.H for DJGPP

				// Version    : 1.4
				// Written by : Luke Lee
				// Last update : 12/22/'95
				// 	update : 12/18/'95
				//      update : 10/21/'95

NEEDS INVOKEC.4TH
NEEDS DOSCMD.4TH

FORTH DEFINITIONS

WARNING @
WARNING OFF

VOCABULARY GRAPHICS

GRAPHICS ALSO DEFINITIONS

0	CONSTANT    GR_80_25_text
1	CONSTANT    GR_default_text
2	CONSTANT    GR_width_height_text
3	CONSTANT    GR_biggest_text
4	CONSTANT    GR_320_200_graphics
5	CONSTANT    GR_default_graphics
6	CONSTANT    GR_width_height_graphics
7	CONSTANT    GR_biggest_noninterlaced_graphics
8	CONSTANT    GR_biggest_graphics
9	CONSTANT    GR_width_height_color_graphics

// return values from 'GrAdapterType()'

0	CONSTANT	 GR_VGA			// VGA adapter 
1	CONSTANT	 GR_EGA			// EGA adapter 
2	CONSTANT	 GR_HERC		// Hercules mono adapter
3	CONSTANT	 GR_8514A		// 8514A or compatible 
4	CONSTANT	 GR_S3			// S3 graphics accelerator 

// ==================================================================
//			CONTEXT AND WINDOW STUFF		      
// ================================================================== 

STRUCT: GrContext
 
    STRUCT: GrVidRAM
    	WORD:  |*gc_baseaddr		// base address of display memory 
    	WORD:  |gc_frameaddr		// upper left corner coordinate 
    	WORD:  |gc_planeoffset		// offset to next color plane 
    	WORD:  |gc_lineoffset		// offset to next scan line in bytes 
    	BYTE:  |gc_onscreen		// is it in video memory ? 
    	BYTE:  |gc_memflags		// memory allocation flags
    ;STRUCT

    WORD:  |gc_xmax			// max X coord (width  - 1) 
    WORD:  |gc_ymax			// max Y coord (height - 1) 
    WORD:  |gc_xcliplo			// low X clipping limit 
    WORD:  |gc_ycliplo			// low Y clipping limit 
    WORD:  |gc_xcliphi			// high X clipping limit 
    WORD:  |gc_ycliphi			// high Y clipping limit 
    WORD:  |gc_usrxbase			// user window min X coordinate 
    WORD:  |gc_usrybase			// user window min Y coordinate 
    WORD:  |gc_usrwidth			// user window width 
    WORD:  |gc_usrheight		// user window height 
    WORD:  |gc_xoffset			// X offset from root's base 
    WORD:  |gc_yoffset			// Y offset from root's base 
    WORD:  |*gc_root			// context which owns frame buf
;STRUCT

// ================================================================== 
//			      COLOR STUFF			      
// ================================================================== 

// Flags to 'OR' to colors for various operations
HEX 

1000000    CONSTANT	 GrXOR		// to "XOR" any color to the screen 
2000000    CONSTANT	 GrOR		// to "OR" to the screen 
3000000    CONSTANT	 GrAND		// to "AND" to the screen 
0	   CONSTANT	 GrWRITE	// write color 
GrXOR  	   CONSTANT	 GrNOCOLOR	// GrNOCOLOR is used for "no" color 

DECIMAL

// ================================================================== 
//			 GRAPHICS PRIMITIVES			      
// ================================================================== 

// framed box colors
 
STRUCT: GrFBoxColors
    WORD:  |fbx_intcolor
    WORD:  |fbx_topcolor
    WORD:  |fbx_rightcolor
    WORD:  |fbx_bottomcolor
    WORD:  |fbx_leftcolor
;STRUCT

512	CONSTANT	 GR_MAX_POLY_VERTICES	

// ================================================================== 
//	      THICK AND DASHED LINE DRAWING PRIMITIVES		      
// ================================================================== 

// * custom line option structure
// *  zero or one dash pattern length means the line is continuous
// *  the dash pattern always begins with a drawn section
 
STRUCT: GrLineOption
    WORD:  |lno_color			// color used to draw line 
    WORD:  |lno_width			// width of the line 
    WORD:  |lno_pattlen			// length of the dash pattern 
    WORD:  |*lno_dashpat		// draw/nodraw pattern 
;STRUCT

// ================================================================== 
//	       PATTERNED DRAWING AND FILLING PRIMITIVES		      
// ================================================================== 

// * BITMAP: a mode independent way to specify a fill pattern of two
// *   colors. It is always 8 pixels wide (1 byte per scan line), its
// *   height is user-defined. SET THE TYPE FLAG TO ZERO!!!
 
STRUCT: GrBitmap
    WORD:  |bmp_ispixmap		// type flag for pattern union 
    WORD:  |bmp_height			// bitmap height 
    WORD:  |*bmp_data			// pointer to the bit pattern 
    WORD:  |bmp_fgcolor			// foreground color for fill 
    WORD:  |bmp_bgcolor			// background color for fill 
    WORD:  |bmp_memflags		// set if dynamically allocated 
;STRUCT

// * PIXMAP: a fill pattern stored in a layout identical to the video RAM
// *   for filling using 'bitblt'-s. It is mode dependent, typically one
// *   of the library functions is used to build it. KEEP THE TYPE FLAG
// *   NONZERO!!!
 
STRUCT: GrPixmap
    WORD:     |pxp_ispixmap	// type flag for pattern union 
    WORD:     |pxp_width	// pixmap width (in pixels)  
    WORD:     |pxp_height	// pixmap height (in pixels) 
    WORD:     |pxp_oper		// bitblt mode (SET, OR, XOR, AND) 
    GrVidRAM  |pxp_source	// source context for fill 
;STRUCT

// * Fill pattern union -- can either be a bitmap or a pixmap

UNION: GrPattern
	WORD:    |gp_ispixmap			// nonzero for pixmaps 
    	GrBitmap |gp_bitmap			// fill bitmap 
	GrPixmap |gp_pixmap			// fill pixmap 
;UNION

// * Draw pattern for line drawings -- specifies both the:
// *   (1) fill pattern, and the
// *   (2) custom line drawing option
 
STRUCT: GrLinePattern
    WORD:  |*lnp_pattern		// fill pattern 
    WORD:  |*lnp_option			// width + dash pattern 
;STRUCT

// ================================================================== 
//		     FONTS AND TEXT PRIMITIVES			      
// ================================================================== 

// * font structure - the part visible to the user.
// * for the internal stuff see "grxfont.h" and "grxfile.h"
// * BE CAREFUL when hacking it! TCC and GCC have to produce the
// * same alignments!!!!
 
16	CONSTANT   GR_NAMEWIDTH

STRUCT: GrFont
    HWORD:   |fnt_width			// width (average for proportional) 
    HWORD:   |fnt_height			// font height 
    HWORD:   |fnt_minchar		// lowest character code in font 
    HWORD:   |fnt_maxchar		// highest character code in font 
    HWORD:   |fnt_isfixed		// nonzero if fixed font 
    HWORD:   |fnt_internal		// nonzero if BIOS font 
    HWORD:   |fnt_baseline		// baseline from top of font 
    HWORD:   |fnt_undwidth		// underline width (at bottom) 
    GR_NAMEWIDTH FIELD:  |fnt_name[]	// font file name (w/o path) 
    GR_NAMEWIDTH FIELD:  |fnt_family[]	// font family name 
;STRUCT

// * text drawing directions
 
0		CONSTANT    GR_TEXT_RIGHT	// normal 
1		CONSTANT    GR_TEXT_DOWN	// downward 
2		CONSTANT    GR_TEXT_LEFT	// upside down, right to left
3		CONSTANT    GR_TEXT_UP		// upward 
GR_TEXT_RIGHT	CONSTANT    GR_TEXT_DEFAULT		

// * text alignment options
 
0		CONSTANT    GR_ALIGN_LEFT	// X only 
0		CONSTANT    GR_ALIGN_TOP	// Y only 
1		CONSTANT    GR_ALIGN_CENTER	// X, Y 
2		CONSTANT    GR_ALIGN_RIGHT	// X only 
2		CONSTANT    GR_ALIGN_BOTTOM	// Y only 
3		CONSTANT    GR_ALIGN_BASELINE	// Y only 
GR_ALIGN_LEFT	CONSTANT    GR_ALIGN_DEFAULT	

// * character types in text strings
 
0	CONSTANT	 GR_BYTE_TEXT		// one byte per character 
1	CONSTANT	 GR_WORD_TEXT		// two bytes per character 
2	CONSTANT	 GR_ATTR_TEXT		// chr w/ PC style attribute byte

// * OR this to the foreground color value for underlined text when
// * using GR_BYTE_TEXT or GR_WORD_TEXT modes.
 
GrXOR 64 * (( << 6 ))	CONSTANT	 GR_UNDERLINE_TEXT

// * text option structure - contains a font and the options specifying
// * how to draw it. The text drawing functions expect a pointer to this.
 
STRUCT: GrTextOption
    WORD:    |*txo_font			// font to be used 
    WORD:    |txo_xmag			// X magnification 

    WORD:    |txo_ymag			// Y magnification 
   // foreground, background 
    UNION:   (fg/bgcolor):
	WORD: |v			// color when no attributes
	WORD: |*p
    ;UNION: 	  |txo_fgcolor
    (fg/bgcolor): |txo_bgcolor

    BYTE:    |txo_direct		// direction (see above) 
    BYTE:    |txo_xalign		// X alignment (see above) 
    BYTE:    |txo_yalign		// Y alignment (see above) 
    BYTE:    |txo_chrtype		// character type (see above)
;STRUCT

// * structure to define a rectangular text window (use fixed fonts only!!)

STRUCT: GrTextRegion 
    WORD:   |*txr_font			// font to be used 
    WORD:   |*txr_buffer		// pointer to text buffer 
    WORD:   |*txr_backup		// optional backup buffer 
    WORD:   |txr_xpos			// upper left corner X coordinate 
    WORD:   |txr_ypos			// upper left corner Y coordinate 
    WORD:   |txr_width			// width of area in chars 
    WORD:   |txr_height			// height of area in chars 
    WORD:   |txr_lineoffset		// offset in buffer(s) between lines 

    (fg/bgcolor): |txr_fgcolor
    (fg/bgcolor): |txr_bgcolor		// foreground, background

    BYTE:    |txr_chrtype		// character type (see above) 
;STRUCT

// //////////////////////////////////////////////////////////////////////////

// ////////////////////////////////////////////// //
//          Graphics Mode Screen I/O		  //
// ////////////////////////////////////////////// //

FALSE VALUE grModeNow?

GrTextOption    grPCTextOption
		grPCTextOption SIZEOF grPCTextOption 0 FILL

80 VALUE grMax#column	// X
30 VALUE grMax#row	// Y

0  VALUE gr_cell_width
0  VALUE gr_cell_height

0 VALUE cursor-location	// cursor location

// //////////////////////////// //
//    Cursor emulation task 	//
// ////////////////////////////	//

0 VALUE grScrollX0
0 VALUE grScrollY0
0 VALUE grScrollX1
0 VALUE grScrollY1

VARIABLE    grCursorCounter
0    VALUE  grCursorStatus
0    VALUE  grCursorScanStart	// cursor scanline
0    VALUE  grCursorScanEnd
$3FF VALUE  grCursorBlinkDelay

GrContext   grScreenContext

GrContext   grCursorContext

CREATE grCursorBuffer 	// 32*32 (1024) Maximum cursor !
	32 32 GrContextSize ALLOT

: grAT?	(( -- col_x row_y ))
	cursor-location  grMax#column /MOD ; 0 2 #PARMS

ALSO GRAPHICS DEFINITIONS

: cell>coordinates	(( col_x row_y -- x y ))
	gr_cell_height * grScrollY0 + SWAP
	gr_cell_width * grScrollX0 + SWAP ; 2 2 #PARMS

PREVIOUS

: grToggleCursor  (| | x y -- |)
	grCursorStatus NOT => grCursorStatus
        grAT? cell>coordinates => y  => x
	GrBitBltNC( NULL , x , y grCursorScanStart + ,
		  grCursorContext , 0 , 0 , gr_cell_width , 
		  grCursorScanEnd gr_cell_height MIN grCursorScanStart - 0 MAX
		  , GrXOR )   ;

: HideCursor	(( -- ))
	grCursorStatus IF  grToggleCursor  ENDIF  ; 0 0 #PARMS

BACKGROUND: CursorTask  (( -- ))
        BEGIN
            grCursorCounter @ grCursorBlinkDelay MOD 0= IF
                grModeNow? IF
                   grToggleCursor
                ENDIF
            ENDIF
            1 grCursorCounter +!
            PAUSE
        AGAIN ;

FORTH DEFINITIONS

: CursorOFF	HideCursor CursorTask SLEEP ; 0 0 #PARMS
: CursorON	CursorTask WAKE ; 0 0 #PARMS
: CursorState	(( -- T/F ))
		CursorTask TASK-STATE LOCAL @ TASK-AWAKE = ; 0 1 #PARMS

VARIABLE Scrolling
Scrolling ON

GRAPHICS DEFINITIONS

: warp-cursor	(( loc -- loc' ))
	grMax#column grMax#row * MOD ; 1 1 #PARMS

: grScrollUp	(( -- ))
	HideCursor
	GrBitBltNC( NULL , grScrollX0 , grScrollY0 , 
		  NULL , grScrollX0 , grScrollY0 gr_cell_height + ,
		  grScrollX1 , grScrollY1 , GrWRITE );
	GrFilledBoxNC( grScrollX0 , grScrollY1 gr_cell_height - 1+ ,
		       grScrollX1 , grScrollY1 , 
		       grPCTextOption |txo_bgcolor |v @   );
	; 0 0 #PARMS

: grScrollDown	(( -- ))
	HideCursor
	GrBitBltNC( NULL , grScrollX0 , grScrollY0 gr_cell_height + ,
		  NULL , grScrollX0 , grScrollY0 , grScrollX1 ,
		  grScrollY1 gr_cell_height - , GrWRITE );
	GrFilledBoxNC( grScrollX0 , grScrollY0 , grScrollX1 ,
		       grScrollY0 gr_cell_height + 1- ,
		       grPCTextOption |txo_bgcolor |v @  );
	; 0 0 #PARMS

: ?scroll	(( loc -- loc' ))
	Scrolling @ IF
	   grMax#column grMax#row * 2DUP >= IF
	       NIP grMax#column -
	       grScrollUp
	   ELSE
	       DROP
	   ENDIF
	ELSE
	   warp-cursor
	ENDIF ; 1 1 #PARMS
        
: grDrawChar	(( ch -- )) // draw character at current cursor location
	>R  grPCTextOption  grAT? cell>coordinates 
	SWAP  R>  GrDrawChar ; 1 0 #PARMS

: grAT	(( col_x row_y -- ))
     //	old : 2 division, 1 multiplication, 1 addition ... slower ( 2 divs )
     //	  grMax#row MOD grMax#column *  SWAP 
     //   grMax#column MOD + => cursor-location
	HideCursor
	grMax#column * + warp-cursor => cursor-location   ; 2 0 #PARMS

FORTH DEFINITIONS

// Only the increment action checks scrolling

: GDrawPoint	(( x y color -- ))
      // GrPlotNC( x , y , color ) ;
	-ROT SWAP GrPlotNC ; 3 0 #PARMS
: GDrawLine	(| x0 y0 x1 y1 color -- |)
	GrLineNC( x0 , y0 , x1 , y1 , color ) ;
: GDrawRectangle (| x0 y0 x1 y1 color -- |)
	GrBoxNC( x0 , y0 , x1 , y1 , color ) ;
: GDrawCircle	(| x0 y0 radius color -- |)
	GrCircle( x0 , y0 , radius , color ) ;

: GImageSize	  (( x0 y0 x1 y1 -- n ))
	ROT - ABS 1+   -ROT - ABS 1+  GrContextSize
	SIZEOF GrContext LITERAL +  ; 4 1 #PARMS

: GGetImage	(| left top right bottom *image -- |)
	GrCreateContext( right left - 1+ , bottom top - 1+ ,
			 *image SIZEOF GrContext LITERAL + , *image ); DROP
	GrBitBlt( *image , 0 , 0 , NULL , left , top , right , bottom ,
		  GrWRITE );
	;
: GPutImage	(| left top *image op -- |)
	GrBitBlt( NULL , left , top , *image , 0 , 0 , 
		  *image |gc_xmax @ , *image |gc_ymax @ , op )  ;

// Graphics region size read
: GSizeX	GrSizeX		; 0 1 #PARMS
: GSizeY	GrSizeY		; 0 1 #PARMS
: GMaxX		GrMaxX		; 0 1 #PARMS
: GMaxY		GrMaxY		; 0 1 #PARMS
// Text region size read
: GSizeColumn	grMax#column	; 0 1 #PARMS // X
: GSizeRow	grMax#row	; 0 1 #PARMS // Y
: GMaxColumn	grMax#column 1- ; 0 1 #PARMS 
: GMaxRow	grMax#row 1- 	; 0 1 #PARMS

DEFER GDrawASCII 1 0 #PARMS
' grDrawChar IS GDrawASCII

: GASCIIEmit	(| ch -- |)
	HideCursor
	ch CASE
	   $07 OF  BEEP			  	  ENDOF
	   $08 OF  AT? SWAP 1- 0 MAX SWAP
		   2DUP AT  BL GDrawASCII  AT	  ENDOF
	   $09 OF  TAB				  ENDOF
	   $0A OF  cursor-location grMax#column +
		   ?scroll => cursor-location     ENDOF	 // LF
	   $0D OF  cursor-location grMax#column
		   TUCK / * => cursor-location    ENDOF	 // CR
	   // Default :
		ch GDrawASCII
		cursor-location 1+  ?scroll  => cursor-location
	ENDCASE ;

GRAPHICS DEFINITIONS

VARIABLE textCONSOLE
'CONSOLE @ textCONSOLE !

: grCONSOLE     (( -- ))
	HideCursor
	['] grDrawChar IS GDrawASCII
	textCONSOLE @EXECUTE
	['] grAT 'AT !		['] grAT? 'AT? !
        ['] GASCIIEmit 'EMIT !	; 0 0 #PARMS

: grNormCursor	(( -- ))
	HideCursor
	gr_cell_height 2 3 */  => grCursorScanStart
	gr_cell_height 4 5 */  => grCursorScanEnd	; 0 0 #PARMS

: grBigCursor	(( -- ))
	HideCursor
	0 => grCursorScanStart
	gr_cell_height => grCursorScanEnd ; 0 0 #PARMS

: grHalfCursor	(( -- ))
	HideCursor
	gr_cell_height 2/  =>  grCursorScanStart
	gr_cell_height 1-  =>  grCursorScanEnd ; 0 0 #PARMS

FORTH DEFINITIONS

: GWouldScroll?	(( +value -- T/F ))
	DUP 0> ANDTHEN
	Scrolling @ ANDTHEN
	DUP cursor-location +  grMax#column grMax#row *  >=
	THEN-AND NIP ; 1 1 #PARMS

: GrCursor++	(( -- ))
	HideCursor cursor-location 1+ ?scroll to cursor-location 
	; 0 0 #PARMS

: GrCursor+!	(( n -- ))
	HideCursor cursor-location +  ?scroll to cursor-location 
	; 1 0 #PARMS

: GrCursor--	(( -- ))
	HideCursor cursor-location 1- warp-cursor to cursor-location 
	; 0 0 #PARMS

: GrCursor-!	(( n -- ))
	HideCursor cursor-location -  warp-cursor to cursor-location
	; 1 0 #PARMS

: GrCursor@	(( -- loc ))
	cursor-location ; 0 1 #PARMS

: GrCursor!	(( n -- ))
	HideCursor warp-cursor to cursor-location ; 1 0 #PARMS

: GrResetTextI/O  (| -- |)
        0 => cursor-location
	grScrollX1 grScrollX0 - 1+  grMax#column  /  =>  gr_cell_width
        grScrollY1 grScrollY0 - 1+  grMax#row     /  =>  gr_cell_height
	HideCursor
	grNormCursor
	GrSetContext( NULL );
	GrSaveContext( grScreenContext ); DROP
	GrCreateContext( gr_cell_width , gr_cell_height , grCursorBuffer , 
			 grCursorContext ); DROP
	GrSetContext( grCursorContext );
	GrFilledBox( 0 , 0 , gr_cell_width , gr_cell_height , GrWhite );
	GrSetContext( grScreenContext );
        grPCTextOption SIZEOF GrTextOption LITERAL ERASE
        GrFindBestFont( gr_cell_width , gr_cell_height , 1 , 
                        Z$" pc*" , grPCTextOption ); DROP

        LIGHTGRAY    grPCTextOption |txo_fgcolor |v   !
        GrBlack      grPCTextOption |txo_bgcolor |v   !

	grModeNow? NOT IF
           ['] grCONSOLE 'CONSOLE !  CONSOLE
	ENDIF ;

: CLS	(( -- ))
	grModeNow? IF
	   HideCursor // if cursor not hided here, 0 0 AT will reveals it.
		      // Since GrFilledBox will clears it, next HideCursor's
		      // XOR operation will sure to reveals it.
	   GrFilledBox( grScrollX0 , grScrollY0 , grScrollX1 , grScrollY1 , 
			grPCTextOption |txo_bgcolor |v @ );
	   0 0 AT
	ELSE
	   CLS	// old CLS
	ENDIF ; 0 0 #PARMS

: GET-SCROLL-RANGE  (( -- X0 Y0 X1 Y1 #col #row ))
	grScrollX0  grScrollY0  grScrollX1 grScrollY1
	grMax#column  grMax#row ; 0 6 #PARMS

// Get____Color is much more frequently used than Set____Color, 
// so make them macros

: GetForeColor (( -- fgcolor )) 
	[ grPCTextOption |txo_fgcolor |v ] LITERAL @  ; 0 1 #PARMS MACRO

: GetBackColor (( -- bgcolor )) 
	[ grPCTextOption |txo_bgcolor |v ] LITERAL @  ; 0 1 #PARMS MACRO

: GetTextColor  (( -- fgcolor bgcolor ))
	[ grPCTextOption |txo_fgcolor |v ] LITERAL @
	[ grPCTextOption |txo_bgcolor |v ] LITERAL @  ; 0 2 #PARMS MACRO

: SetTextColor	(( fgcolor bgcolor -- ))
	[ grPCTextOption |txo_bgcolor |v ] LITERAL !  
	[ grPCTextOption |txo_fgcolor |v ] LITERAL !  ; 2 0 #PARMS

: SET-SCROLL-RANGE  (| X0 Y0 X1 Y1 #col #row | fgcolor bgcolor -- |)
     // if '#col' or '#row' less than zero, use current cell-size
	X1 X0 >  ANDTHEN  Y1 Y0 > ANDTHEN 
	X1 GrMaxX <= ANDTHEN  Y1 GrMaxY <=  THEN-AND IF
	   X0 => grScrollX0  Y0 => grScrollY0
	   X1 => grScrollX1  Y1 => grScrollY1
	   #col 0> IF
	       #col  
	   ELSE  
	       grScrollX1 grScrollX0 - 1+ gr_cell_width /  
	   ENDIF  => grMax#column
	   #row 0> IF  
	       #row  
	   ELSE  
	       grScrollY1 grScrollY0 - 1+ gr_cell_height /  
	   ENDIF  => grMax#row
	   GetTextColor to bgcolor to fgcolor
	   GrResetTextI/O
	   fgcolor bgcolor OR 0<> IF  fgcolor bgcolor SetTextColor  ENDIF
	ELSE
	   ." * SET-SCROLL-RANGE : Invalid scroll range" CR ABORT
	ENDIF ;

: GRAPHICS-MODE	(( -- ))
	GrSetMode( GR_default_graphics , 0 , 0 , 0 );
	getenv( Z$" GRXFONT" ) 0= IF
	   GrSetFontPath( Z$" .\fonts" );
	ELSE
	   GrSetFontPath( getenv( Z$" GRXFONT" ) );
	ENDIF
        0  0  GrMaxX  GrMaxY  80  30  SET-SCROLL-RANGE 
	TRUE => grModeNow?   ; 0 0 #PARMS

: TEXT-MODE	(| -- |)
	grModeNow? IF  GrBlack GrClearScreen  ENDIF
	GrSetMode( GR_80_25_text , 0 , 0 , 0 );
	FALSE => grModeNow?
        textCONSOLE @ 'CONSOLE !
        CONSOLE ;

GRAPHICS ALSO HIDDEN ALSO DEFINITIONS

#EXISTED (dokey) #IF

0 VALUE grCursorType

: grSetCursorShape
	grCursorType IF   grHalfCursor   ELSE  grNormCursor  ENDIF ; 0 0 #PARMS

: grCursorChangeShape
	grCursorType NOT => grCursorType
	grSetCursorShape ; 0 0 #PARMS

is-insert? #IF  grCursorChangeShape  #ENDIF

: gr(dokey)	(( buf #chars_got #max_got key -- #chars_got' #max_got' ))
	DUP ins = IF
	   grCursorChangeShape
	ENDIF
	DEFERS dokey ; 4 2 #PARMS

' gr(dokey) IS dokey

#ENDIF
			
: BYE-RESTORE	(( -- ))
	[ BYEFUNC^ @ ] LITERAL EXECUTE
	grModeNow? IF  TEXT-MODE  ENDIF ; 0 0 #PARMS

' BYE-RESTORE BYEFUNC^ !

CursorTask WAKE MULTI

FORTH DEFINITIONS

STRUCT: GrTextInfo:
	  WORD: |InfoSaved?		INVIS	// INVISIBLE
	  WORD: |grModeNow?		INVIS
	  WORD: |grMax#column		INVIS
	  WORD: |grMax#row		INVIS
   GrTextOption |grPCTextOption		INVIS	// structure
   	  WORD: |gr_cell_width		INVIS
	  WORD: |gr_cell_height		INVIS
	  WORD: |cursor-location	INVIS
	  WORD: |grScrollX0		INVIS
   	  WORD:	|grScrollY0		INVIS
	  WORD:	|grScrollX1		INVIS
	  WORD:	|grScrollY1		INVIS
	  WORD:	|grCursorScanStart	INVIS
	  WORD:	|grCursorScanEnd	INVIS
	  WORD:	|grCursorBlinkDelay	INVIS
	  WORD: |grCursorType		INVIS
	  WORD: |CursorState		INVIS
	  WORD: |Scrolling		INVIS	// the only variable
;STRUCT

: GrSaveTextInfo	(( GrTextInfo -- ))	RECURSIVE
	HideCursor >R
	['] GrSaveTextInfo    R@ |InfoSaved? !	// a special flag for checking
	grModeNow?	      R@ |grModeNow?		!
	grMax#column	      R@ |grMax#column		!
	grMax#row	      R@ |grMax#row		!
	grPCTextOption	      R@ |grPCTextOption
			          SIZEOF GrTextOption LITERAL CMOVE
	gr_cell_width	      R@ |gr_cell_width		!
	gr_cell_height	      R@ |gr_cell_height	!	
	cursor-location	      R@ |cursor-location	!
	grScrollX0	      R@ |grScrollX0		!
	grScrollY0	      R@ |grScrollY0		!
	grScrollX1	      R@ |grScrollX1		!
	grScrollY1	      R@ |grScrollY1		!
	grCursorScanStart     R@ |grCursorScanStart	!
	grCursorScanEnd	      R@ |grCursorScanEnd	!
	grCursorBlinkDelay    R@ |grCursorBlinkDelay	!
	grCursorType	      R@ |grCursorType		!
	CursorState	      R@ |CursorState		!
	Scrolling @	      R@ |Scrolling		!
	RDROP ; 1 0 #PARMS
	
: GrRestoreTextInfo	(( GrTextInfo -- ))
	>R 
	R@ |InfoSaved? @ ['] GrSaveTextInfo = IF // valid info.
	   R@ |grModeNow? @ grModeNow? NOT AND IF  GRAPHICS-MODE  ENDIF
	   R@ |grMax#column 	  @ to grMax#column
	   R@ |grMax#row 	  @ to grMax#row
	   R@ |grPCTextOption grPCTextOption SIZEOF GrTextOption LITERAL CMOVE
	   R@ |gr_cell_width	  @ to gr_cell_width
	   R@ |gr_cell_height	  @ to gr_cell_height
	   R@ |cursor-location	  @ GrCursor!
	   R@ |grScrollX0	  @ to grScrollX0
	   R@ |grScrollY0	  @ to grScrollY0
	   R@ |grScrollX1	  @ to grScrollX1
	   R@ |grScrollY1	  @ to grScrollY1
	   R@ |grCursorScanStart  @ to grCursorScanStart
	   R@ |grCursorScanEnd	  @ to grCursorScanEnd
	   R@ |grCursorBlinkDelay @ to grCursorBlinkDelay
	   R@ |grCursorType	  @ to grCursorType
	   R@ |CursorState	  @ IF  CursorON  ELSE  CursorOFF  ENDIF
	   R@ |Scrolling	  @ Scrolling !
	ELSE
	   ." Not a valid GrTextInfo" CR BEEP
	ENDIF RDROP ; 1 0 #PARMS

GRAPHICS DEFINITIONS

GrTextInfo: GrShellToDosTextInfo

0 VALUE GrIsMulti?

: GrShellToDOS 	(( -- ))
	MULTI? to GrIsMulti? SINGLE
	GrShellToDosTextInfo GrSaveTextInfo
	grModeNow? IF TEXT-MODE ENDIF
	DEFERS ShellToDosHook ; 0 0 #PARMS

: GrBackFromDOS	(( -- ))
	DEFERS BackFromDosHook
	GrShellToDosTextInfo |grModeNow? @ IF  
	   ." ... Press any key to continue ..." CR KEY DROP
	ENDIF
	GrShellToDosTextInfo GrRestoreTextInfo
	GrIsMulti? IF MULTI ENDIF ; 0 0 #PARMS

' GrShellToDOS  IS ShellToDosHook
' GrBackFromDOS IS BackFromDosHook

FORTH DEFINITIONS

ONLY GRAPHICS ALSO FORTH DEFINITIONS

WARNING !

