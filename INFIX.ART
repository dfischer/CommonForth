//
//  Infix grammar sample with LL(k) Compiler .
//
				// 09/21/'95  Written by  : Luke Lee
				//            Version     : 1.0
				//            Last update : 09/22/'95

OPTIMIZE OFF
NEEDS LL(k)GEN.ART

VOCABULARY INFIX
INFIX ALSO DEFINITIONS

FALSE VALUE ShowInfix? INVISIBLE

CREATE LineBuffer  512 ALLOT

VARIABLE FIRSTWORD

: Concat  (( A$ -- ))
	// Concat current token to LineBuffer with a trailing space 
	LineBuffer SWAP COUNT $+ "  " $+ DROP ;

: ConcatThis  (( -- ))  ThisToken Concat  ;

' ConcatThis ALIAS #append

// Since the 'semantic stack' (YACC) has not been implemented in LL(k).4TH,
// I had to deal with semantic myself.

: #append_op:
      ' >BODY \ LITERAL COMPILE Concat ; IMMEDIATE

: op_concator:  
	CREATE
	   9 ALLOT
	DOES> 
	   ThisToken SWAP 9 CMOVE ;

CREATE uniary_op 9 ALLOT 

op_concator: #logical_op
op_concator: #relational_op  
op_concator: #adding_op      
op_concator: #multiplying_op
op_concator: #exponational_op
op_concator: #abs_op

//
//  Token defining 
//

CR .( Defining Token ) CR

STR" +"   T: '+'   ;T
STR" -"   T: '-'   ;T
STR" *"   T: '*'   ;T
STR" /"   T: '/'   ;T
STR" )"   T: ')'   ;T
STR" ="   T: '='   ;T
STR" <"   T: '<'   ;T
STR" >"   T: '>'   ;T
STR" <>"  T: "<>"  ;T
STR" <="  T: "<="  ;T
STR" >="  T: ">="  ;T
STR" **"  T: "**"  ;T
STR" F+"  T: "F+"  ;T
STR" F-"  T: "F-"  ;T
STR" F*"  T: "F*"  ;T
STR" F/"  T: "F/"  ;T
STR" F**" T: "F**" ;T
STR" NOT" T: "NOT" ;T
STR" AND" T: "AND" ;T
STR" OR"  T: "OR"  ;T
STR" XOR" T: "XOR" ;T
STR" MOD" T: "MOD" ;T
STR" ABS" T: "ABS" ;T
STR" FABS" T: "FABS" ;T

//
//  Grammar defining
//
CR .( Defining Grammar ) CR

.( Production rule 1) CR
P: <primary> -> { DROP GetToken C@ 0<> }  // anything not NULL
	     ;P
.( Production rule 2) CR
P: <logical_op> -> "AND"        { #logical_op }
		-> "OR"         { #logical_op }
		-> "XOR"        { #logical_op }
		;P

.( Production rule 3) CR
P: <relational_op> -> '='       { #relational_op }
		   -> "<>"      { #relational_op }
		   -> '<'       { #relational_op }
		   -> "<="      { #relational_op }
		   -> '>'       { #relational_op }
		   -> ">="      { #relational_op }
		   ;P

.( Production rule 4) CR
P: <adding_op> -> '+'           { #adding_op }
	       -> '-'           { #adding_op }
	       -> "F+"          { #adding_op }
	       -> "F-"          { #adding_op }
	       ;P

.( Production rule 5) CR
P: <multiplying_op> -> '*'      { #multiplying_op }
		    -> '/'      { #multiplying_op }
		    -> "F*"     { #multiplying_op }
		    -> "F/"     { #multiplying_op }
		    -> "MOD"    { #multiplying_op }
		    ;P

.( Production rule 6) CR
P: <abs_op> -> "ABS"            { #abs_op }
	    -> "FABS"           { #abs_op }
	    ;P

// <expo_op> -> **
//           -> F**
// <factor> -> [ <uniary adding op> ] <primary> [ <expo op> <primary> ]
//          -> [ <uniary adding op> ] ABS <primary>
//          -> NOT <primary>

.( Production rule 7) CR
P: <exponational_op> -> "**"      { #exponational_op }
			<primary> { #append #append_op: #exponational_op }
		     -> "F**"     { #exponational_op }
			<primary> { #append #append_op: #exponational_op }
		     ;P

.( Production rule 8) CR
P: <uniary_op> -> '+' { 0 uniary_op ! }
	       -> '-' { $" NEGATE" uniary_op OVER C@ 1+ CMOVE }
	       ;P

.( Production rule 9) CR
P: <factor> -> [[ <uniary_op> ]] <abs_op>
	       <primary> { #append #append_op: #abs_op #append_op: uniary_op }
	    -> [[ <uniary_op> ]] <primary> { #append }
	       [[ <exponational_op> { #append_op: uniary_op } ]]
	    -> "NOT" <primary> { #append  $" NOT" Concat }
	    ;P

.( Production rule 10) CR
P: <term> -> <factor> 
	     {{ <multiplying_op> <factor> { #append_op: #multiplying_op } }}
	  ;P

.( Production rule 11) CR
P: <simple_expr> -> <term> {{ <adding_op> <term> { #append_op: #adding_op } }}
		 ;P


.( Production rule 12) CR
P: <relation> -> <simple_expr> {{ <relational_op> <simple_expr> 
				  { #append_op: #relational_op } }}
	      ;P

.( Production rule 13) CR
P: <expression> -> <relation> {{ <logical_op> <relation> 
				 { #append_op: #logical_op } }}
		;P

.( Production rule 14) CR
P: <infix_expr_rest> -> <expression> ')'    // the rest of infix expression
		     -> ')'
		     ;P

FORTH DEFINITIONS

: **    (( a b -- a^b ))
	FOR 1 AFT OVER * THEN NEXT NIP ; 2 1 #PARMS

: (     (( -- ))
	0 LineBuffer !
	TRUE <infix_expr_rest> IF
	   ShowInfix? IF 
	      CR ." LineBuffer : " CR LineBuffer COUNT TYPE CR 
	   ENDIF
	   LineBuffer COUNT TRANSLATE ?DUP IF THROW ENDIF
	ELSE
	   ." * Infix syntax error. " CR ABORT
	ENDIF ; IMMEDIATE

: .INFIX   ShowInfix?  NOT TO ShowInfix?  ;     // toggle displaying

ONLY FORTH ALSO DEFINITIONS

